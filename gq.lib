#!/bin/bash
#
# Copyright (c) Josef "Jeff" Sipek, 2006
#

function find_git_dir_nice
{
	git-rev-parse --git-dir
}

function find_git_dir
{
	local d=`find_git_dir_nice`

	[ $? -ne 0 -o -z "$d" ] && exit 1

	echo "$d"
}

function get_branch
{
	git-symbolic-ref HEAD | sed -e 's,^refs/heads/,,'
}

function get_branch_verify
{
	local b=`get_branch`

	[ ! -d "$GIT_DIR/patches/$b" ] && echo "Branch $b is not initialized, try gq-init" >&2 && exit 1
	[ ! -f "$GIT_DIR/patches/$b/series" ] && echo "Branch $b does not have a series file" >&2 && exit 1
	[ ! -f "$GIT_DIR/patches/$b/status" ] && echo "Branch $b does not have a status file" >&2 && exit 1
	[ -f "$GIT_DIR/patches/$b/applied" ] && echo "Warning: Branch $b has 'applied' file - gq is not compatible with stgit" >&2

	echo "$b"
}

function get_top
{
	tail -1 $GQ_DIR/$branch/status
}

function get_prev
{
	local n=`wc -l < $GQ_DIR/$branch/status`
	local n=`expr $n - 1`

	local idx=0
	for p in `cat $GQ_DIR/$branch/status`; do
		idx=`expr $idx + 1`
		[ $idx -lt $n ] && continue
		[ $idx -gt $n ] && break

		echo $p
	done
}

# usage: index_update_magic
function index_update_magic
{
	while read l; do
		fil=`echo $l | cut -d: -f 2`
		git-update-index --add --remove "$fil"
	done
}

# usage: do_get_header patchfile
function do_get_header
{
	cat $1 | awk 'BEGIN{ok=1}/^(diff|---)/{ok=0}{if (ok==1) print $0}'
}

# usage: pop_patch
function pop_patch
{
	git reset --hard HEAD^

	head -n -1 < $applied > $applied.tmp
	mv $applied{.tmp,}
}

# usage: push_patch patchname
function push_patch
{
	local p="$GQ_DIR/$branch/$1"
	local pname="$1"

	git-apply --reject $p > /dev/null 2> /tmp/gq.log.$$
	local bail=$?
	[ $bail -ne 0 ] && cat /tmp/gq.log.$$

	[ $bail -ne 0 ] && cat /tmp/gq.log.$$ >&2

	( git-apply --numstat $p | awk '{print "changed:" $3}';
	#git-apply --summary $p | awk '
	#	/^ (create|delete)/{print $1 ":" $4}
	#	/^ mode change/{print "mode:" $6}'
	)| index_update_magic

	# grab a commit message out of the patch
	do_get_header $p > /tmp/gq.msg.$$

	# make a default commit message if patch doesn't contain one
	[ ! -s /tmp/gq.msg.$$ ] && echo "patch $pname" > /tmp/gq.msg.$$

	# commit
	local treeish=`git-write-tree`
	local commitish=`git-commit-tree $treeish -p HEAD < /tmp/gq.msg.$$`
	echo $commitish > $GIT_DIR/`git-symbolic-ref HEAD`

	rm -f /tmp/gq.msg.$$ /tmp/gq.log.$$

	return $bail
}

# usage: must_commit_first
function must_commit_first
{
	[ `git-diff-files | wc -l` -eq 0 ]
	return $?
}

# usage: refresh_patch patchname
function refresh_patch
{
	local p="$GQ_DIR/$branch/$1"

	git-diff-files --name-only | (while read n; do git-update-index $n ; done)

	# get the patch header
	do_get_header $p > /tmp/gq.diff.$$

	# get the new patch
	git-diff HEAD^ >> /tmp/gq.diff.$$

	# drop the current commit
	git-reset --hard HEAD^

	# move the new patch in
	mv $p $p.prev
	mv /tmp/gq.diff.$$ $p

	push_patch $1
}

